<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>刷题小笔记01</title>
      <link href="2021/03/07/shua-ti-xiao-bi-ji-01/"/>
      <url>2021/03/07/shua-ti-xiao-bi-ji-01/</url>
      
        <content type="html"><![CDATA[<h3 id="C语言中的优先级问题"><a href="#C语言中的优先级问题" class="headerlink" title="C语言中的优先级问题"></a>C语言中的优先级问题</h3><p>我们在使用C语言判断一个整数的奇偶性时通常会使用如下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(n % 2 &#x3D;&#x3D; 0)</span><br></pre></td></tr></table></figure><p>还有一种方式就是使用按位与运算，让整数n与1进行按位与运算，奇数二进制表示中最后一位一定为1，然后问题就出现了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、  if(n &amp; 1 &#x3D;&#x3D; 0)</span><br><span class="line"></span><br><span class="line">2、  if((n &amp; 1) &#x3D;&#x3D; 0)</span><br></pre></td></tr></table></figure><p>我在进行判断时习惯性地使用了方法1，但是得到的结果差了很多，检查其他代码无误后发现n的值变化和预期的不太一样，于是考虑到优先级问题</p><p>首先第一种方法中<code>==</code>号的优先级高于<code>&amp;</code>，所以每一次进入if语句中都是在计算<code>n &amp; 0</code>,结果肯定是false，而在第二种方法中则是先计算括号中的内容，然后再判断是否等于0</p>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统03</title>
      <link href="2021/03/03/shu-ju-ku-xi-tong-03/"/>
      <url>2021/03/03/shu-ju-ku-xi-tong-03/</url>
      
        <content type="html"><![CDATA[<h2 id="第3章：结构化查询语言-Structured-Query-Language（SQL）"><a href="#第3章：结构化查询语言-Structured-Query-Language（SQL）" class="headerlink" title="第3章：结构化查询语言 Structured Query Language（SQL）"></a>第3章：结构化查询语言 Structured Query Language（SQL）</h2><h3 id="3-1-SQL数据定义"><a href="#3-1-SQL数据定义" class="headerlink" title="3.1 SQL数据定义"></a>3.1 SQL数据定义</h3><ul><li>基本数据类型</li></ul><ol><li>SQL提供的基本数据类型有：数值型、日期时间型、串型、枚举型<ol><li>数值型：<ol><li>整型</li><li>定点型：DECIMAL(p,s):有效数字共p位，小数点后s位</li><li>浮点型：float:单精度，4字节  double:双精度，8字节</li><li>二进制数型：BIT（b）:b位二进制数（1&lt;=b&lt;=64）,（b+7）/8字节，输入时用b’101’表示5</li></ol></li><li>日期时间型：<ol><li>YEAR:1字节整数 ‘YYYY’</li><li>DATE:3字节整数 ‘YYYY-MM-DD’</li><li>TIME:3字节整数 ‘HH:MM:SS’</li><li>DATETIME:8字节整数 ‘YYYY-MM-DD HH:MM:SS’</li><li>TIMESTAMP:四字节整数 ‘YYYY-MM-DD HH:MM:SS’</li></ol></li><li>字符串型：<ol><li>CHAR（n）:定长字符串型，n&lt;=255,不足n个时用空格补全</li><li>VARCHAR（n）:变长字符串型，n&lt;=65535</li><li>TEXT文本型：<ul><li>TINYTEXT:$L \leq 2^8$</li><li>TEXT:$L \leq 2^{16}$</li><li>MEDIUMTEXT:$L \leq 2^{24}$</li><li>LONGTEXT:$L \leq 2^{32}$</li></ul></li></ol></li><li>二进制串型：<ol><li>BINARY(n):定长二进制串型，最多存储n个字节，$n \leg 255$,不足位置用\0补全</li><li>VARBINARY(n):边长二进制串型，$n \leg 65535$</li><li>BLOB:二进制对象型(Binary Large Object)<ul><li>TINYBLOB:$L \leq 2^8$</li><li>BLOB:$L \leq 2^{16}$</li><li>MEDIUMBLOB:$L \leq 2^{24}$</li><li>LONGBLOB:$L \leq 2^{32}$</li></ul></li></ol></li><li>枚举型ENUM:<ol><li>例：ENUM(‘Mercury’,’Venus’,’Earth’,’Mars’)</li><li>枚举型的值只能取自值列表</li><li>值列表中最多包含65535个不同的值</li><li>如果值列表包含之多255个值，则占1字节；如果值列表中包含超过255个值，则占2字节</li></ol></li><li>集合型SET:<ol><li>例：SET(‘Mercury’,’Venus’,’Earth’,’Mars’)</li><li>集合型的值只能是值集合的子集</li><li>值列表中最多包含64个不同的值</li><li>存储为二进制数，列表中每个值对应一个二进制位。值在子集中存在，则相应位置为1</li><li>例如：’Mercury,Earth’存储为1010（此处存疑，ppt上面写的是0101）</li><li>占用空间大小取决于集合中元素的个数</li></ol></li></ol></li></ol><ul><li>创建关系模式功能：定义关系模式，</li></ul><ul><li>修改关系模式</li><li>删除关系模式</li><li>定义视图</li></ul><h3 id="3-2-SQL数据更新"><a href="#3-2-SQL数据更新" class="headerlink" title="3.2 SQL数据更新"></a>3.2 SQL数据更新</h3><h3 id="3-3-SQL数据查询"><a href="#3-3-SQL数据查询" class="headerlink" title="3.3 SQL数据查询"></a>3.3 SQL数据查询</h3>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统02</title>
      <link href="2021/02/25/shu-ju-ku-xi-tong-02/"/>
      <url>2021/02/25/shu-ju-ku-xi-tong-02/</url>
      
        <content type="html"><![CDATA[<h2 id="第2章：关系数据库-Relational-Database"><a href="#第2章：关系数据库-Relational-Database" class="headerlink" title="第2章：关系数据库 Relational Database"></a>第2章：关系数据库 Relational Database</h2><h3 id="2-1-关系数据库模型-Relational-Data-Model"><a href="#2-1-关系数据库模型-Relational-Data-Model" class="headerlink" title="2.1 关系数据库模型 Relational Data Model"></a>2.1 关系数据库模型 Relational Data Model</h3><p>关系数据模型是一种被广泛使用的实现数据模型（Implementation data model）</p><p>关系数据模型的三要素</p><ul><li>关系数据结构</li><li>关系操作</li><li>关系完整性约束</li></ul><p>关系数据模型要素1：关系数据结构</p><ul><li>关系数据模型使用唯一的数据结构–关系(relation)</li><li>不严格地讲，关系就是一张二维表(table)<ol><li>行 —— 元组(tuple)/记录(record)，表示对象</li><li>列 —— 属性(attribute)/域(field)，表示对象的性质</li></ol></li></ul><table><thead><tr><th>Sno</th><th>Sname</th><th>Sno</th><th>Sname</th><th>Sno</th></tr></thead><tbody><tr><td>221101</td><td>Nick</td><td>M</td><td>20</td><td>Physics</td></tr><tr><td>231101</td><td>Elsa</td><td>F</td><td>19</td><td>CS</td></tr><tr><td>231102</td><td>Eric</td><td>M</td><td>19</td><td>CS</td></tr><tr><td>232101</td><td>Abby</td><td>F</td><td>18</td><td>Math</td></tr></tbody></table><p>关系的定义：设$D_1D_2{\ldots}D_n $ 是n个值域(Domain),$D_1{\times}D_2{\times}{\ldots}{\times}D_n $ 的子集R称作$D_1D_2{\ldots}D_n $ 上的关系</p><p>注：${\times} 为笛卡尔乘积$</p><p>$D_1$ = 学号集合, $D_2$ = 姓名集合, $D_3$ = {M, F}, $D_4$ = N, $D_5$ = 系名集合</p><p>Student ${\subseteq} D_1{\times}D_2{\times}{\ldots}{\times}D_n $</p><p>关系的正确性：</p><p>$D_1{\times}D_2{\times}{\ldots}{\times}D_n $的任意自己都是关系，但未必都是正确的关系，只有符合客观实际的关系才是正确的关系.比如一个人不可以有两个年龄</p><p>关系的属性(Attributes)：</p><p>Attributes(属性)：由于域可能相同，为了加以区分，可以为关系$R(D_1,D_2,{\ldots},D_n)$的每个域$D_i$起一个不同的名字$A_i$,称作属性</p><p>关系的键(Keys):关系的某些属性具有区分不同元组的作用，称作键(key)</p><ul><li><p>超键(super key)：如果关系的某一组属性的值能唯一标识每个元组，则称该属性为超键</p><ol><li>例：在关系（Grade,StudentNo, CourseNo, Score）中，属性组{StudentNo, CourseNo}就是超键</li></ol></li><li><p>候选键（candidate key）:如果一个超键的任意子集都不是超键，则称该超键为候选键</p></li><li><p>主键（orimary key）:一个关系有至少一个候选键，指定其中一个作为主键</p></li></ul><p>不同关系的元组可以存在联系，这种联系是通过外键建立起来的：</p><ul><li>设F是关系R的属性子集，但F不是R的主键。若F与关系S的主键K相对应，则称F是R的外键（foreign key）</li></ul><p><img src="foreignkey.png" alt="外键"></p><p>关系数据模型要素2：关系操作</p><ul><li>查询操作：从关系数据库种查找数据</li><li>更新操作：对关系数据库进行更新<ul><li>插入数据</li><li>修改数据</li><li>删除数据</li></ul></li></ul><p>查询语言：用于表示关系操作的语言</p><ul><li>关系代数</li><li>关系演算</li><li>结构化查询语言SQL</li></ul><p>关系数据模型元素3：关系完整性约束</p><ul><li>完整性约束（integrity constraints）:关系数据库中的所有数据必须满足的约束条件</li><li>完整性约束的类型<ul><li>实体完整性（entity integrity）</li><li>参照完整性（referential integrity）</li><li>用户定义完整性（user-defined integrity）</li></ul></li></ul><p>实体完整性约束：</p><ul><li>关系中任意元组的主键必须唯一</li><li>关系中任意元组的主键不能为空（not null）<ul><li>空值（null）表示值不存在，既不是0，又不是空串</li></ul></li></ul><p>参照完整性约束：</p><ul><li>设F是关系R的外键，F参照关系S的主键，则R中任意元组的F属性值必须满足以下两个条件之一：<ul><li>F的值为空</li><li>若F的值不为空，则F的值必须在S中存在</li></ul></li></ul><p><img src="constrain.png" alt="参照完整性约束"></p><p>用户定义完整性约束：</p><ul><li>根据应用需求定义的完整性约束条件<ul><li>考试成绩在0-100之间</li><li>性别必须为’M’或’F’</li></ul></li></ul><h3 id="2-2-关系代数-Relational-Algebra"><a href="#2-2-关系代数-Relational-Algebra" class="headerlink" title="2.2 关系代数 Relational Algebra"></a>2.2 关系代数 Relational Algebra</h3><p>关系代数是一种使用关系运算（operation）表达式来表示查询的语言</p><p>关系代数查询表达式明确给出了查询的执行过程</p><p>关系运算的三要素</p><ul><li>运算对象：关系</li><li>运算符：选择$\sigma$、投影$\prod$、笛卡尔积$\times$、并$\bigcup$、差-、重命名$\rho$、交$\bigcap$、连接（写不出来的字符）等</li><li>运算结果：关系</li></ul><p><img src="connect.png" alt="连接"></p><p>关系代数基本操作：</p><ol><li>选择$\sigma$</li><li>投影$\prod$</li><li>笛卡尔积$\times$</li><li>并$\bigcup$</li><li>差-</li><li>重命名$\rho$</li></ol><h3 id="2-3-文件"><a href="#2-3-文件" class="headerlink" title="2.3 文件"></a>2.3 文件</h3><p>一步步讲解太过麻烦</p><p><a href="ch2_handout.pdf" title="pdf">点击下载</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统01</title>
      <link href="2021/02/24/shu-ju-ku-xi-tong-01/"/>
      <url>2021/02/24/shu-ju-ku-xi-tong-01/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h2><p>数据：一个可以记录并且有语义的事实</p><p>数据类型：</p><ul><li>按照数据的类型分类<ol><li>简单结构数据库：关系数据库，时\空数据库</li><li>复杂结构数据库：图数据库</li><li>半结构化数据：XML, JSON</li><li>非结构化数据：文本，音视频，图像等</li></ol></li><li>按照数据存储的方式<ol><li>单机数据库</li><li>分布式数据库</li><li>并行数据库</li></ol></li><li>按照数据存储的介质<ol><li>内存数据库、流数据库</li></ol></li></ul><p>数据管理：</p><ul><li>定义数据类型，结构以及约束</li><li>建立与加载，根据定义好的数据结构，建立或者加载起来</li><li>操作数据库<ol><li>数据检索：查询，生成报告(generating reports)</li><li>由一组并发用户和应用程序处理和共享数据，但仍保持所有数据有效和一致</li><li>安全，访问控制，归档(archiving)</li></ol></li></ul><p>数据管理方法：</p><ul><li>文件系统方法</li><li>数据库系统方法</li><li>NoSQL方法</li><li>大数据方法</li></ul><p>内存层级：</p><p><img src="MemoryHierarchy.png" alt="内存层级"></p><h3 id="1-1-基本概念-Basic-Concepts"><a href="#1-1-基本概念-Basic-Concepts" class="headerlink" title="1.1 基本概念(Basic Concepts)"></a>1.1 基本概念(Basic Concepts)</h3><p>数据库Database(DB):一组有组织的，共享的并且持续的数据</p><p>数据库管理系统Database Management System(DBMS):一种通用的系统软件，可促进各种用户和应用程序之间数据库的组织，存储，操纵，控制和维护</p><p>数据库用户Database Users:</p><ul><li>Database administrators(DBA)</li><li>Database designers</li><li>End users</li></ul><p>数据库系统Database System(DBS):一个包含了数据库，数据库管理系统以及使用人员应用程序的系统</p><p><img src="DBS.png" alt="数据库系统"></p><h3 id="1-2-数据库管理系统功能-Function-of-DBMS"><a href="#1-2-数据库管理系统功能-Function-of-DBMS" class="headerlink" title="1.2 数据库管理系统功能(Function of DBMS)"></a>1.2 数据库管理系统功能(Function of DBMS)</h3><ul><li>数据定义：定义数据模式</li><li>数据存储：结构化存储以及访问方法</li><li>数据操作：数据查询以及数据更新</li><li>数据控制：事务管理，数据完整性，数据安全行，并发控制，故障恢复</li><li>数据维护：数据输入，数据转换，数据存档，数据恢复，性能监控</li></ul><h3 id="1-3-数据库系统的特点-Features-of-Database-Systems"><a href="#1-3-数据库系统的特点-Features-of-Database-Systems" class="headerlink" title="1.3 数据库系统的特点(Features of Database Systems)"></a>1.3 数据库系统的特点(Features of Database Systems)</h3><ul><li>结构化数据的组织</li><li>数据分享</li><li>低数据冗余度</li><li>数据独立性(Data Independence):物理独立性以及逻辑独立性</li><li>数据由数据库系统管理</li></ul><h3 id="1-4-数据模型-Data-Models"><a href="#1-4-数据模型-Data-Models" class="headerlink" title="1.4 数据模型(Data Models)"></a>1.4 数据模型(Data Models)</h3><p>数据抽象：现实世界到计算机世界的映射</p><p>数据模型：数据抽象的重要工具</p><ul><li>结构：一系列的描述数据库结构的概念</li><li>操作：管理这些结构的操作</li><li>约束：数据库应该遵守的约束</li></ul><p>数据模型的范畴(Catagories):</p><ul><li>概念数据模型 Conceptual (high-level, semantic) data models</li><li>物理数据模型 Physical (low-level, internal) data models</li><li>实现(代表性)数据模型 Implementation (representational) data models<ol><li>分层数据模型 </li><li>网络数据模型 </li><li>关系数据模型（主要内容）：用表的集合表示数据与数据之间的关系 </li><li>实体-对象模型（E-R模型）： </li><li>面向对象数据模型：ER模型增加了封装，方法标识的一个扩展 </li><li>关系对象数据模型 </li><li>半结构化数据模型 </li><li>文档数据模型 </li><li>图数据模型</li></ol></li></ul><p>约束(Constraints):</p><ul><li>Entity constraints</li><li>Referential constraints</li><li>User-defined constraint</li></ul><h3 id="1-5-数据库模式-Database-Schemas"><a href="#1-5-数据库模式-Database-Schemas" class="headerlink" title="1.5 数据库模式 Database Schemas"></a>1.5 数据库模式 Database Schemas</h3><p>数据库模式(Schemas):对数据库的描述，包括对数据库结构，数据类型和对数据库约束的描述</p><p>数据库实例(Instance):在某个特定时刻存储在数据库中的真实的数据</p><p>Schemas vs Instance</p><ul><li>The database schema is the “type”</li><li>The database instance is the “value”</li><li>The database schema changes very infrequently</li><li>The database instance changes every time the database is updated</li></ul><p>三层模式结构：</p><ul><li>概念模式(Conceptual schema)</li><li>内模式(Internal schema)</li><li>外模式(External schema)</li></ul><p><img src="Three-Schema.png" alt="三种模式结构"></p><p>内模式(Internal schema)</p><ul><li>描述物理存储结构和访问方法</li><li>只有一种内模式</li><li>通常使用物理数据模式</li></ul><p>概念模式(Conceptual schema)</p><ul><li>为所以用户描述整个数据库的结构和约束</li><li>只有一种概念模式</li><li>使用概念或者实现数据模型(Use a conceptual or an implementation data model)</li></ul><p>外模式</p><ul><li>描述各种用户视角</li><li>可以有超过一个的外模式</li><li>通常使用相同的数据模型作为概念模式</li></ul><p>实例：最上层有不同的学生表的视图，如只能看到ID，姓名和级别的表，中间是具体的存储表是怎样的 结构，最底下是存储这些数据的物理方式，如数组索引的存储等</p><p><img src="Three-Schema-Example.png" alt="三种模式结构实例"></p><p>模式映射(Schema Mapping):模式之间的映射需要传递需求与数据</p><ul><li>需求传递(Request transformation):外模式-&gt;内模式</li><li>数据传递(Data transformation):内模式-&gt;外模式</li></ul><p>模式映射的范畴(Categories of Schema Mappings)</p><ul><li>External/conceptual mapping: mapping from an external schema to the conceptual schema</li><li>Conceputual/internal mapping: mapping from the conceptual schema to the internal schema</li></ul><p>数据独立(Data Independence)</p><ul><li>当一个低层级的模式发生改变时，只有该模式与其高层模式之间的映射发生改变</li><li>高层级模式本身是不变的</li><li>应用程序参考的外模式不需要改变</li></ul><p>数据独立的范畴(Categories of Data Independence)</p><ul><li>逻辑数据独立(Logical data independence):改变概念模式不会改变外模式以及应用程序对外模式的参考</li><li>物理数据独立(Physical data independence):改变内模式不会改变概念模式</li></ul><h3 id="1-6-数据库语言-Database-Language"><a href="#1-6-数据库语言-Database-Language" class="headerlink" title="1.6 数据库语言 Database Language"></a>1.6 数据库语言 Database Language</h3><p>描述式语言：只描述目标，但不描述如何实现</p><p>数据库语言包含：</p><ul><li>数据定义语言Data definition languages (DDL)</li><li>数据操作语言Data manipulation languages (DML)</li></ul><h3 id="1-7-数据库系统结构"><a href="#1-7-数据库系统结构" class="headerlink" title="1.7 数据库系统结构"></a>1.7 数据库系统结构</h3><p><img src="DBMSArchetictures.png" alt="数据库系统结构"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.828-Lab1</title>
      <link href="2021/01/17/mit6-828-lab1/"/>
      <url>2021/01/17/mit6-828-lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT-6-828-Lab1"><a href="#MIT-6-828-Lab1" class="headerlink" title="MIT 6.828 Lab1"></a>MIT 6.828 Lab1</h1><h2 id="MIT6-828-Lab1-Part2-pointers"><a href="#MIT6-828-Lab1-Part2-pointers" class="headerlink" title="MIT6.828 Lab1 Part2 pointers"></a><a href="https://www.bilibili.com/video/BV1qz4y167xr">MIT6.828 Lab1 Part2 pointers</a></h2><p>实验中有一部分要求我们复习C语言基础，主要是指针方面的知识：</p><p><img src="MIT6.828-Lab1-pointers-1.png"></p><p>我们需要做的工作就是运行官方所给的pointers.c文件，然后弄明白每次数据a中的元素都是什么</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line">void f(void)</span><br><span class="line">&#123;</span><br><span class="line">   int a[4];</span><br><span class="line">   int *b = malloc(16);</span><br><span class="line">   int *c;</span><br><span class="line">   int i;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;1: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);</span><br><span class="line"></span><br><span class="line">   c = a;</span><br><span class="line">   <span class="keyword">for</span> (i = 0; i &lt; 4; i++)</span><br><span class="line">a[i] = 100 + i;</span><br><span class="line">   c[0] = 200;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">   a[0], a[1], a[2], a[3]);</span><br><span class="line"></span><br><span class="line">   c[1] = 300;</span><br><span class="line">   *(c + 2) = 301;</span><br><span class="line">   3[c] = 302;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">   a[0], a[1], a[2], a[3]);</span><br><span class="line"></span><br><span class="line">   c = c + 1;</span><br><span class="line">   *c = 400;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">   a[0], a[1], a[2], a[3]);</span><br><span class="line"></span><br><span class="line">   c = (int *) ((char *) c + 1);</span><br><span class="line">   *c = 500;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">   a[0], a[1], a[2], a[3]);</span><br><span class="line"></span><br><span class="line">   b = (int *) a + 1;</span><br><span class="line">   c = (int *) ((char *) a + 1);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;6: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int ac, char **av)</span><br><span class="line">&#123;</span><br><span class="line">   f();</span><br><span class="line">   <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看一下运行结果，然后逐句分析一下：</p><p><img src="MIT6.828-Lab1-pointers-2.png" alt="pointers.c运行结果"></p><p>代码首先定义了四个变量，然后打印前三个变量的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a[4];</span><br><span class="line">int *b = malloc(16);</span><br><span class="line">int *c;</span><br><span class="line">int i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);</span><br></pre></td></tr></table></figure><p>系统在分配地址的时候有其自己的算法，所以这三个地址我们是无法预估的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c = a;</span><br><span class="line"><span class="keyword">for</span> (i = 0; i &lt; 4; i++)</span><br><span class="line">a[i] = 100 + i;</span><br><span class="line">c[0] = 200;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">  a[0], a[1], a[2], a[3]);</span><br></pre></td></tr></table></figure><p>第二部分将a的地址赋值给c，此时对c和a的操作都相当于对a的操作，所以打印a数组的时候会显示    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200 101 102 103</span><br></pre></td></tr></table></figure><p>接下来第三部分    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c[1] = 300;`</span><br><span class="line">*(c + 2) = 301;`</span><br><span class="line">3[c] = 302;`</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">  a[0], a[1], a[2], a[3]);</span><br></pre></td></tr></table></figure><p>这部分考察的是寻址方式，这部分可以参考csapp（深入理解计算机系统）的第三章121页，里面讲了寻址方式</p><p><img src="MIT6.828-Lab1-pointers-3.png" alt="寻址方式">    </p><p>实际操作都是对于数据a的操作，所以打印出的内容为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200 300 301 302</span><br></pre></td></tr></table></figure><p>再接着：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = c + 1;</span><br><span class="line">*c = 400;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">  a[0], a[1], a[2], a[3]);</span><br></pre></td></tr></table></figure><p>我们都知道，c是一个<code>int *</code>型的指针变量,所以执行<code>c=c+1</code>就相当于c的地址向后移位一个整型数字的大小，所以此时c所指向的地址为a[1]的地址，对c的操作就相当于对a[1]的操作，所以第四次打印较第三次来说只有a[1]的值发生了变化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200 400 301 302</span><br></pre></td></tr></table></figure><p>然后是第五次打印</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = (int *) ((char *) c + 1);</span><br><span class="line">*c = 500;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">  a[0], a[1], a[2], a[3]);</span><br></pre></td></tr></table></figure><p>这次非常特别的将c的地址转换成字符型加一然后又转换成整型，此时c指向的地址即不是a[1]又不是a[2]，而是a[1]和a[2]之间的位置，在这个时候写入500，那么肯定会导致a[1] a[2]的值都发生变化，如下图所示：</p><p><img src="MIT6.828-Lab1-pointers-4.png"></p><p>首先观察3和4，我们需要知道的是我们的编译环境是32位的，所以一个整数占32位，然后是该系统采用小端模式，高地址在前，低地址在后，所以我们在写入数据的时候也是从高地址写入低地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">500用十六进制表示为：0x000001F4</span><br></pre></td></tr></table></figure><p>c的地址原来指向a[1]，向后移位一个字符后则指向<code>$a[1]+8</code>bit大小，所以向C写入500时我们要将前8位写入a[2]的后8位，把500的后24位写入a[1]的前24位，如上图所示，所以写入后显示如下数字<br>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200 128144 256 302</span><br></pre></td></tr></table></figure><p>最后一次打印，有了前面的介绍我们可以知道b的地址在a[0]的地址向后移位一个整型的大小，即32位，而c的位置为a[0]向后移位一个字符型的大小，8位。打印的内容如下所示：    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0061FEF4  0061FEF8  0061FEF5</span><br></pre></td></tr></table></figure><p>其他具体的介绍也可以参考<a href="https://www.bilibili.com/video/BV1qz4y167xr">视频链接</a></p><h2 id="MIT6-828-Lab1-Part3-The-Kernel"><a href="#MIT6-828-Lab1-Part3-The-Kernel" class="headerlink" title="MIT6.828 Lab1 Part3:The Kernel"></a>MIT6.828 Lab1 Part3:The Kernel</h2><h3 id="Exercise7"><a href="#Exercise7" class="headerlink" title="Exercise7"></a><a href="https://www.bilibili.com/video/BV1DK4y1W7kB">Exercise7</a></h3><p><img src="MIT6-828-Lab1-Part3-1.png"></p><p>第一部分与虚拟内存映射有关联，主要表述的内容为：</p><ol><li>我们的操作系统使用了4MB的物理内存</li><li>观察kern/entry.s文件可以得到，设置CR0_PG标志位之后就可以进行虚拟内存映射</li><li>具体的映射方式为高地址0xf0000000 - 0xf0400000的4MB物理地址映射到0x00000000 - 0x00400000，物理地址0x00000000~0x00400000依旧映射到0x00000000 - 0x00400000</li></ol><p>要求我们验证CR0_PG标志位设置前后0x100000与0xf0100000两处物理地址存储的内容：</p><p>分析一下，根据我们的映射方式，0xf0100000与0x100000对应一个地址，所以在进行映射之前两者对应的内存不同，映射之后对应的内存相同</p><p>entry.s中有一句<br>    <code>movl %eax, %cr0</code></p><p>此句的作用就是设置CRO_PG，所以我们使用qemu和gdb定位到此句，查看执行前后两段内存中对应的内容即可</p><p>下面开始进行操作：</p><p>首先我们需要找到上面的代码，我们的代码在执行过bootmain之后跳转到entry函数的执行，所以我们只需要在bootmain的最后一行一句一句向后执行就能找到</p><p><img src="MIT6-828-Lab1-Part3-2.png"></p><p>我们可以看到，该代码在0x00100025，此时是不能进行地址映射的，所以查看内存如下：</p><p><img src="MIT6-828-Lab1-Part3-3.png"></p><p>可以看到两个位置所存储的内容不同，使用<code>si</code>指令向下执行之后再次查看内存</p><p><img src="MIT6-828-Lab1-Part3-4.png"></p><p>可以看到设置好CR0_PG之后确实可以进行地址映射</p><h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><blockquote><p>Most people take functions like printf() for granted, sometimes even thinking of them as “primitives” of the C language. But in an OS kernel, we have to implement all I/O ourselves.</p></blockquote><blockquote><p>Read through kern/printf.c, lib/printfmt.c, and kern/console.c, and make sure you understand their relationship. It will become clear in later labs why printfmt.c is located in the separate lib directory.</p></blockquote><p>首先我们要了解三个与打印相关的文件，分别为 \kern\printf.c，\kern\console.c, \lib\printfmt.c<br>简单了解里面的函数调用关系之后我们发现printf.c与printfmt.c都是调用了console.c文件中的函数，所以我们先来看console.c</p><p>这里我们主要关心的是被多次调用的cputchar函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// `High<span class="string">&#x27;-level console I/O.  Used by readline and cprintf.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void</span></span><br><span class="line"><span class="string">cputchar(int c)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cons_putc(c);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// output a character to the console</span></span><br><span class="line"><span class="string">static void</span></span><br><span class="line"><span class="string">cons_putc(int c)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">serial_putc(c);</span></span><br><span class="line"><span class="string">lpt_putc(c);</span></span><br><span class="line"><span class="string">cga_putc(c);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>通过注释我们可以发现，cputchar()函数是控制台IO最高层的控制程序，所以它被另外两个文件所调用。再有就是cons_putc()函数的作用是向控制台，也就是计算机屏幕输出一个字符</p><p>下面我们来具体看一下这三个函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define COM1        0x3F8</span></span><br><span class="line"><span class="comment">#define COM_TX        0    // Out: Transmit buffer (DLAB=0)</span></span><br><span class="line"><span class="comment">#define COM_LSR        5    // In:    Line Status Register</span></span><br><span class="line"><span class="comment">#define COM_LSR_TXRDY    0x20    //   Transmit buffer avail</span></span><br><span class="line"></span><br><span class="line">static void serial_putc(int c)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = 0;</span><br><span class="line">     !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; 12800;</span><br><span class="line">     i++)</span><br><span class="line">delay();</span><br><span class="line"></span><br><span class="line">outb(COM1 + COM_TX, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过inb与outb函数我们可以知道这段程序是从一个端口读于一个字节的数据，然后写入另一个端口。<br>关于端口的内容我们可以查看<a href="http://bochs.sourceforge.net/techspec/PORTS.LST">这里</a></p><p><img src="Lab1-Part3-5.png"></p><p><img src="Lab1-Part3-6.png"></p><p>这里我们可以看到，我们从端口03FD读取字节，而该端口的bit5=1时说明此时这个寄存器为空，计算机可以向该寄存器发送数据，读取出的内容与0x20做与运算后再取反，此时就会退出循环，执行outb函数</p><p>接下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/***** Parallel port output code *****/</span><br><span class="line">// For information on PC parallel port programming, see the class References</span><br><span class="line">// page.</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">lpt_putc(int c)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = 0; !(inb(0x378+1) &amp; 0x80) &amp;&amp; i &lt; 12800; i++)</span><br><span class="line">delay();</span><br><span class="line">outb(0x378+0, c);</span><br><span class="line">outb(0x378+2, 0x08|0x04|0x01);</span><br><span class="line">outb(0x378+2, 0x08);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的作用就是将字符输出给并口设备，至于为什么要做些操作，可能就是计算机设计者的问题了，本人并不清楚</p><blockquote><p>0378-037A —-    parallel printer port, same as 0278 and 03BC<br>0378    w    data port<br>0379    r/w    status port<br>037A    r/w    control port</p></blockquote><p>可以看到，0x0379是状态端口，通过端口数据可以知道是否可以写入，然后0x0378写入数据，0x037A端口写入一些控制</p><p>最后一个cga_putc函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">static void cga_putc(int c)</span><br><span class="line">&#123;</span><br><span class="line">// <span class="keyword">if</span> no attribute given, <span class="keyword">then</span> use black on white</span><br><span class="line"><span class="keyword">if</span> (!(c &amp; ~0xFF))</span><br><span class="line">c |= 0x0700;</span><br><span class="line"></span><br><span class="line">switch (c &amp; 0xff) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\b&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (crt_pos &gt; 0) &#123;</span><br><span class="line">crt_pos--;</span><br><span class="line">crt_buf[crt_pos] = (c &amp; ~0xff) | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">crt_pos += CRT_COLS;</span><br><span class="line">/* fallthru */</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">crt_pos -= (crt_pos % CRT_COLS);</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">default:</span><br><span class="line">crt_buf[crt_pos++] = c;/* write the character */</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// What is the purpose of this?</span><br><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123; //如果要打印的内容比CRT屏幕承受的范围大</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">//那么就上移一行，然后将最后一行全部涂黑</span><br><span class="line">memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));</span><br><span class="line"><span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">crt_buf[i] = 0x0700 | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">crt_pos -= CRT_COLS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move that little blinky thing */</span><br><span class="line">outb(addr_6845, 14);</span><br><span class="line">outb(addr_6845 + 1, crt_pos &gt;&gt; 8);</span><br><span class="line">outb(addr_6845, 15);</span><br><span class="line">outb(addr_6845 + 1, crt_pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，cga是我们的屏幕设备名称，put是输出的意思，c是我们函数里面一直使用的那个变量，所以函数的意思就是向屏幕输出c</p><p>但这里面的c并不是一个字符c，他是一个int型变量，占32位，每一位的作用如下所示：</p><table><thead><tr><th align="center">15 14 13 12</th><th align="center">11 10 9 8</th><th align="center">7 6 5 4 3 2 1</th></tr></thead><tbody><tr><td align="center">背景色</td><td align="center">前景色</td><td align="center">字符</td></tr></tbody></table><p><img src="Lab1-Part3-7.png"></p><p>所以该函数前几句的意思就是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">if</span> no attribute given, <span class="keyword">then</span> use black on white</span><br><span class="line"><span class="keyword">if</span> (!(c &amp; ~0xFF))</span><br><span class="line">c |= 0x0700;</span><br></pre></td></tr></table></figure><p>如果c=0x0000,那么就将c转换为0x0700,二进制表示为0000 0111 0000 0000</p><p>说明显示背景为黑色，前景为白色，而字符0x00用ASCii码表示则为空，该函数的其余部分就是讨论c的类型以及不同的打印状态，这里我并没有仔细研究</p><p>看完console.c之后我们来看printfmt.c,这个函数的作用就是</p><blockquote><p> Stripped-down primitive printf-style formatting routines,<br> used in common by printf, sprintf, fprintf, etc.<br> This code is also used by both the kernel and user programs.</p></blockquote><p>然后是printf.c</p><blockquote><p> Simple implementation of cprintf console output for the kernel,<br> based on printfmt() and the kernel console’s cputchar().</p></blockquote><p>接下来则要求我们完善printfmt.c中关于八进制%o的代码</p><blockquote><p>We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form “%o”. Find and fill in this code fragment.</p></blockquote><p>如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// (unsigned) octal</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">putch(<span class="string">&#x27;0&#x27;</span>, putdat);</span><br><span class="line">num = getuint(&amp;ap, lflag);</span><br><span class="line">base = 8;</span><br><span class="line">goto number;</span><br></pre></td></tr></table></figure><p>这里面主要是模仿十进制的代码进行编写即可，其中getuint函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Get an unsigned int of various possible sizes from a varargs list,</span><br><span class="line">// depending on the lflag parameter.</span><br><span class="line">static unsigned long long</span><br><span class="line">getuint(va_list *ap, int lflag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lflag &gt;= 2)</span><br><span class="line"><span class="built_in">return</span> va_arg(*ap, unsigned long long);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (lflag)</span><br><span class="line"><span class="built_in">return</span> va_arg(*ap, unsigned long);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">return</span> va_arg(*ap, unsigned int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的作用就是获取一个不同长度的无符号数</p><p>再往下就是一些练习题，我们一个个看</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
